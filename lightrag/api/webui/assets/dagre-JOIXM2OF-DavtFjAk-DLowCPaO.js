import{g as v,b as L,c as M,m as j,f as F,I as t,x as Y,Q as H,e as q,X as Q,i as $,j as z,l as D,o as K,q as U,s as V}from"./index-CZRndaym.js";import{L as B}from"./graph-XBA1gVZB-Jq5LHYyU.js";import{o as W}from"./layout-BjQAOOOn-BsN08Foq.js";import{E as S}from"./_baseUniq-C8e369Jq-BCn2ExtQ.js";import{a as Z}from"./clone-BnhFz35D-CEQ-rl-3.js";import{g as k}from"./_basePickBy-I_8Sje-O-tfj9PR-i.js";function X(e){var n={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:_(e),edges:ee(e)};return S(e.graph())||(n.value=Z(e.graph())),n}function _(e){return k(e.nodes(),function(n){var r=e.node(n),s=e.parent(n),d={v:n};return S(r)||(d.value=r),S(s)||(d.parent=s),d})}function ee(e){return k(e.edges(),function(n){var r=e.edge(n),s={v:n.v,w:n.w};return S(n.name)||(s.name=n.name),S(r)||(s.value=r),s})}var u=new Map,N=new Map,G=new Map,ne=v(()=>{N.clear(),G.clear(),u.clear()},"clear"),I=v((e,n)=>{const r=N.get(n)||[];return t.trace("In isDescendant",n," ",e," = ",r.includes(e)),r.includes(e)},"isDescendant"),re=v((e,n)=>{const r=N.get(n)||[];return t.info("Descendants of ",n," is ",r),t.info("Edge is ",e),e.v===n||e.w===n?!1:r?r.includes(e.v)||I(e.v,n)||I(e.w,n)||r.includes(e.w):(t.debug("Tilt, ",n,",not in descendants"),!1)},"edgeInCluster"),J=v((e,n,r,s)=>{t.warn("Copying children of ",e,"root",s,"data",n.node(e),s);const d=n.children(e)||[];e!==s&&d.push(e),t.warn("Copying (nodes) clusterId",e,"nodes",d),d.forEach(c=>{if(n.children(c).length>0)J(c,n,r,s);else{const o=n.node(c);t.info("cp ",c," to ",s," with parent ",e),r.setNode(c,o),s!==n.parent(c)&&(t.warn("Setting parent",c,n.parent(c)),r.setParent(c,n.parent(c))),e!==s&&c!==e?(t.debug("Setting parent",c,e),r.setParent(c,e)):(t.info("In copy ",e,"root",s,"data",n.node(e),s),t.debug("Not Setting parent for node=",c,"cluster!==rootId",e!==s,"node!==clusterId",c!==e));const l=n.edges(c);t.debug("Copying Edges",l),l.forEach(f=>{t.info("Edge",f);const E=n.edge(f.v,f.w,f.name);t.info("Edge data",E,s);try{re(f,s)?(t.info("Copying as ",f.v,f.w,E,f.name),r.setEdge(f.v,f.w,E,f.name),t.info("newGraph edges ",r.edges(),r.edge(r.edges()[0]))):t.info("Skipping copy of edge ",f.v,"-->",f.w," rootId: ",s," clusterId:",e)}catch(C){t.error(C)}})}t.debug("Removing node",c),n.removeNode(c)})},"copy"),P=v((e,n)=>{const r=n.children(e);let s=[...r];for(const d of r)G.set(d,e),s=[...s,...P(d,n)];return s},"extractDescendants"),te=v((e,n,r)=>{const s=e.edges().filter(l=>l.v===n||l.w===n),d=e.edges().filter(l=>l.v===r||l.w===r),c=s.map(l=>({v:l.v===n?r:l.v,w:l.w===n?n:l.w})),o=d.map(l=>({v:l.v,w:l.w}));return c.filter(l=>o.some(f=>l.v===f.v&&l.w===f.w))},"findCommonEdges"),x=v((e,n,r)=>{const s=n.children(e);if(t.trace("Searching children of id ",e,s),s.length<1)return e;let d;for(const c of s){const o=x(c,n,r),l=te(n,r,o);if(o)if(l.length>0)d=o;else return o}return d},"findNonClusterChild"),O=v(e=>!u.has(e)||!u.get(e).externalConnections?e:u.has(e)?u.get(e).id:e,"getAnchorId"),ie=v((e,n)=>{if(!e||n>10){t.debug("Opting out, no graph ");return}else t.debug("Opting in, graph ");e.nodes().forEach(function(r){e.children(r).length>0&&(t.warn("Cluster identified",r," Replacement id in edges: ",x(r,e,r)),N.set(r,P(r,e)),u.set(r,{id:x(r,e,r),clusterData:e.node(r)}))}),e.nodes().forEach(function(r){const s=e.children(r),d=e.edges();s.length>0?(t.debug("Cluster identified",r,N),d.forEach(c=>{const o=I(c.v,r),l=I(c.w,r);o^l&&(t.warn("Edge: ",c," leaves cluster ",r),t.warn("Descendants of XXX ",r,": ",N.get(r)),u.get(r).externalConnections=!0)})):t.debug("Not a cluster ",r,N)});for(let r of u.keys()){const s=u.get(r).id,d=e.parent(s);d!==r&&u.has(d)&&!u.get(d).externalConnections&&(u.get(r).id=d)}e.edges().forEach(function(r){const s=e.edge(r);t.warn("Edge "+r.v+" -> "+r.w+": "+JSON.stringify(r)),t.warn("Edge "+r.v+" -> "+r.w+": "+JSON.stringify(e.edge(r)));let d=r.v,c=r.w;if(t.warn("Fix XXX",u,"ids:",r.v,r.w,"Translating: ",u.get(r.v)," --- ",u.get(r.w)),u.get(r.v)||u.get(r.w)){if(t.warn("Fixing and trying - removing XXX",r.v,r.w,r.name),d=O(r.v),c=O(r.w),e.removeEdge(r.v,r.w,r.name),d!==r.v){const o=e.parent(d);u.get(o).externalConnections=!0,s.fromCluster=r.v}if(c!==r.w){const o=e.parent(c);u.get(o).externalConnections=!0,s.toCluster=r.w}t.warn("Fix Replacing with XXX",d,c,r.name),e.setEdge(d,c,s,r.name)}}),t.warn("Adjusted Graph",X(e)),A(e,0),t.trace(u)},"adjustClustersAndEdges"),A=v((e,n)=>{var r,s;if(t.warn("extractor - ",n,X(e),e.children("D")),n>10){t.error("Bailing out");return}let d=e.nodes(),c=!1;for(const o of d){const l=e.children(o);c=c||l.length>0}if(!c){t.debug("Done, no node has children",e.nodes());return}t.debug("Nodes = ",d,n);for(const o of d)if(t.debug("Extracting node",o,u,u.has(o)&&!u.get(o).externalConnections,!e.parent(o),e.node(o),e.children("D")," Depth ",n),!u.has(o))t.debug("Not a cluster",o,n);else if(!u.get(o).externalConnections&&e.children(o)&&e.children(o).length>0){t.warn("Cluster without external connections, without a parent and with children",o,n);let l=e.graph().rankdir==="TB"?"LR":"TB";(s=(r=u.get(o))==null?void 0:r.clusterData)!=null&&s.dir&&(l=u.get(o).clusterData.dir,t.warn("Fixing dir",u.get(o).clusterData.dir,l));const f=new B({multigraph:!0,compound:!0}).setGraph({rankdir:l,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});t.warn("Old graph before copy",X(e)),J(o,e,f,o),e.setNode(o,{clusterNode:!0,id:o,clusterData:u.get(o).clusterData,label:u.get(o).label,graph:f}),t.warn("New graph after copy node: (",o,")",X(f)),t.debug("Old graph after copy",X(e))}else t.warn("Cluster ** ",o," **not meeting the criteria !externalConnections:",!u.get(o).externalConnections," no parent: ",!e.parent(o)," children ",e.children(o)&&e.children(o).length>0,e.children("D"),n),t.debug(u);d=e.nodes(),t.warn("New list of nodes",d);for(const o of d){const l=e.node(o);t.warn(" Now next level",o,l),l!=null&&l.clusterNode&&A(l.graph,n+1)}},"extractor"),T=v((e,n)=>{if(n.length===0)return[];let r=Object.assign([],n);return n.forEach(s=>{const d=e.children(s),c=T(e,d);r=[...r,...c]}),r},"sorter"),oe=v(e=>T(e,e.children()),"sortNodesByHierarchy"),R=v(async(e,n,r,s,d,c)=>{t.warn("Graph in recursive render:XAX",X(n),d);const o=n.graph().rankdir;t.trace("Dir in recursive render - dir:",o);const l=e.insert("g").attr("class","root");n.nodes()?t.info("Recursive render XXX",n.nodes()):t.info("No nodes found for",n),n.edges().length>0&&t.info("Recursive edges",n.edge(n.edges()[0]));const f=l.insert("g").attr("class","clusters"),E=l.insert("g").attr("class","edgePaths"),C=l.insert("g").attr("class","edgeLabels"),h=l.insert("g").attr("class","nodes");await Promise.all(n.nodes().map(async function(g){const a=n.node(g);if(d!==void 0){const i=JSON.parse(JSON.stringify(d.clusterData));t.trace(`Setting data for parent cluster XXX
 Node.id = `,g,`
 data=`,i.height,`
Parent cluster`,d.height),n.setNode(d.id,i),n.parent(g)||(t.trace("Setting parent",g,d.id),n.setParent(g,d.id,i))}if(t.info("(Insert) Node XXX"+g+": "+JSON.stringify(n.node(g))),a!=null&&a.clusterNode){t.info("Cluster identified XBX",g,a.width,n.node(g));const{ranksep:i,nodesep:w}=n.graph();a.graph.setGraph({...a.graph.graph(),ranksep:i+25,nodesep:w});const m=await R(h,a.graph,r,s,n.node(g),c),b=m.elem;H(a,b),a.diff=m.diff||0,t.info("New compound node after recursive render XAX",g,"width",a.width,"height",a.height),q(b,a)}else n.children(g).length>0?(t.trace("Cluster - the non recursive path XBX",g,a.id,a,a.width,"Graph:",n),t.trace(x(a.id,n)),u.set(a.id,{id:x(a.id,n),node:a})):(t.trace("Node - the non recursive path XAX",g,h,n.node(g),o),await Q(h,n.node(g),{config:c,dir:o}))})),await v(async()=>{const g=n.edges().map(async function(a){const i=n.edge(a.v,a.w,a.name);t.info("Edge "+a.v+" -> "+a.w+": "+JSON.stringify(a)),t.info("Edge "+a.v+" -> "+a.w+": ",a," ",JSON.stringify(n.edge(a))),t.info("Fix",u,"ids:",a.v,a.w,"Translating: ",u.get(a.v),u.get(a.w)),await $(C,i)});await Promise.all(g)},"processEdges")(),t.info("Graph before layout:",JSON.stringify(X(n))),t.info("############################################# XXX"),t.info("###                Layout                 ### XXX"),t.info("############################################# XXX"),W(n),t.info("Graph after layout:",JSON.stringify(X(n)));let p=0,{subGraphTitleTotalMargin:y}=z(c);return await Promise.all(oe(n).map(async function(g){var a;const i=n.node(g);if(t.info("Position XBX => "+g+": ("+i.x,","+i.y,") width: ",i.width," height: ",i.height),i!=null&&i.clusterNode)i.y+=y,t.info("A tainted cluster node XBX1",g,i.id,i.width,i.height,i.x,i.y,n.parent(g)),u.get(i.id).node=i,D(i);else if(n.children(g).length>0){t.info("A pure cluster node XBX1",g,i.id,i.x,i.y,i.width,i.height,n.parent(g)),i.height+=y,n.node(i.parentId);const w=i?.padding/2||0,m=((a=i?.labelBBox)==null?void 0:a.height)||0,b=m-w||0;t.debug("OffsetY",b,"labelHeight",m,"halfPadding",w),await K(f,i),u.get(i.id).node=i}else{const w=n.node(i.parentId);i.y+=y/2,t.info("A regular node XBX1 - using the padding",i.id,"parent",i.parentId,i.width,i.height,i.x,i.y,"offsetY",i.offsetY,"parent",w,w?.offsetY,i),D(i)}})),n.edges().forEach(function(g){const a=n.edge(g);t.info("Edge "+g.v+" -> "+g.w+": "+JSON.stringify(a),a),a.points.forEach(b=>b.y+=y/2);const i=n.node(g.v);var w=n.node(g.w);const m=U(E,a,u,r,i,w,s);V(a,m)}),n.nodes().forEach(function(g){const a=n.node(g);t.info(g,a.type,a.diff),a.isGroup&&(p=a.diff)}),t.warn("Returning from recursive render XAX",l,p),{elem:l,diff:p}},"recursiveRender"),ue=v(async(e,n)=>{var r,s,d,c,o,l;const f=new B({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:((r=e.config)==null?void 0:r.nodeSpacing)||((d=(s=e.config)==null?void 0:s.flowchart)==null?void 0:d.nodeSpacing)||e.nodeSpacing,ranksep:((c=e.config)==null?void 0:c.rankSpacing)||((l=(o=e.config)==null?void 0:o.flowchart)==null?void 0:l.rankSpacing)||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),E=n.select("g");L(E,e.markers,e.type,e.diagramId),M(),j(),F(),ne(),e.nodes.forEach(h=>{f.setNode(h.id,{...h}),h.parentId&&f.setParent(h.id,h.parentId)}),t.debug("Edges:",e.edges),e.edges.forEach(h=>{if(h.start===h.end){const p=h.start,y=p+"---"+p+"---1",g=p+"---"+p+"---2",a=f.node(p);f.setNode(y,{domId:y,id:y,parentId:a.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),f.setParent(y,a.parentId),f.setNode(g,{domId:g,id:g,parentId:a.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),f.setParent(g,a.parentId);const i=structuredClone(h),w=structuredClone(h),m=structuredClone(h);i.label="",i.arrowTypeEnd="none",i.id=p+"-cyclic-special-1",w.arrowTypeStart="none",w.arrowTypeEnd="none",w.id=p+"-cyclic-special-mid",m.label="",a.isGroup&&(i.fromCluster=p,m.toCluster=p),m.id=p+"-cyclic-special-2",m.arrowTypeStart="none",f.setEdge(p,y,i,p+"-cyclic-special-0"),f.setEdge(y,g,w,p+"-cyclic-special-1"),f.setEdge(g,p,m,p+"-cyc<lic-special-2")}else f.setEdge(h.start,h.end,{...h},h.id)}),t.warn("Graph at first:",JSON.stringify(X(f))),ie(f),t.warn("Graph after XAX:",JSON.stringify(X(f)));const C=Y();await R(E,f,e.type,e.diagramId,void 0,C)},"render");export{ue as render};
